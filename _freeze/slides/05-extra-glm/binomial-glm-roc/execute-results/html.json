{
  "hash": "88a501fba444a030336975abc6907a1b",
  "result": {
    "markdown": "---\ntitle: ROC and GLM\ninstitute: \"\\\\@event | Place\"\nauthor: \n  - name: \"Filippo Gambarota\"\n    email: filippo.gambarota@unipd.it\n    github: filippogambarota\nformat: \n  quarto-slides-revealjs:\n    slide-number: true\n    incremental: false\n    code-link: true\n    code-line-numbers: false\n    html-math-method: mathjax\n    margin: 0\n    filters:\n      - nutshell\n      - code-fullscreen\nfrom: markdown+emoji\ndate: last-modified\nfinal-slide: true\ndf-print: default\nbibliography: \"https://raw.githubusercontent.com/filippogambarota/bib-database/main/references.bib\"\ncsl: \"https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\"\ntoc: true\ntoc-title: Contents\ntoc-depth: 1\nengine: knitr\n---\n\n\n\n\n\n\n\n\n\n\n\n\n## Binomial GLM - ROC analysis \n\n- The ROC curve is a tool to assess the performance of a classifier (e.g., binomial regression). The idea is to use several different threshold to create the 0/1 predictions (instead of 0.5 as in the previous slides) and find the optimal value.\n\n- The Binomial GLM can predict 0-1 values and we can compare the predictions with the real response $y$. The match between predictions and truth is an index on how well the model works.\n\n- This is very common in machine learning but we need to take care about overfitting (beyond the scope of this presentation) in terms of train-test splitting of original data.\n\n## ROC analysis: an example\n\n- We want to validate a new questionnaire that implement an updated and shorter form of another questionnaire (*gold-standard*).\n\n- We collect $n$ people with the *gold-standard* (i.e., the \"truth\") and with the new questionnaire.\n\n- We calibrate the new questionnaire to maximize the ability to correctly classify a person having or not having a certain condition.\n\n## Binomial GLM - ROC analysis \n\nLet's simulate some data for a Binomial GLM:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-6-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Binomial GLM - ROC analysis \n\nThe $x$ variable is the new questionnaire and the $y$ variable is the classification based on the gold-standard. In this case we consider $y$ the **truth**.\n\nNow, to classify people based on the new questionnaire we need to choose a **threshold** $t$. In terms that $\\hat y = 1$ when $x > t$ and $\\hat y = 0$ otherwise. We can then summarize everthing in a contingency table (aka confusion matrix): \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt <- 0.75\npi <- ifelse(dat$x > t, 1, 0)\nyi <- dat$y\n\n# confusion matrix\ntable(pi, yi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>    yi\n#> pi   0  1\n#>   0 26  9\n#>   1  2 13\n```\n:::\n:::\n\n\n## Contingency tables (CT)\n\nCTs are tables that summarize 2 or more categorical variables using absolute or relative frequencies.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/contingency-table.svg){fig-align='center' width=70%}\n:::\n:::\n\n\n## Contingency tables (CT)\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table style=\"border-collapse:collapse; border:none;\">\n <tr>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal; border-bottom:1px solid;\" rowspan=\"2\">x</th>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal;\" colspan=\"2\">y</th>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal; font-weight:bolder; font-style:italic; border-bottom:1px solid; \" rowspan=\"2\">Total</th>\n </tr>\n \n<tr>\n <td style=\"border-bottom:1px solid; text-align:center; padding:0.2cm;\">1</td>\n <td style=\"border-bottom:1px solid; text-align:center; padding:0.2cm;\">0</td>\n </tr>\n \n<tr> \n<td style=\"padding:0.2cm;  text-align:left; vertical-align:middle;\">1</td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">41</span><br><span style=\"color:#993333;\">27.3&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">34</span><br><span style=\"color:#993333;\">22.7&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;  \"><span style=\"color:black;\">75</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td> \n</tr>\n \n<tr> \n<td style=\"padding:0.2cm;  text-align:left; vertical-align:middle;\">0</td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">42</span><br><span style=\"color:#993333;\">28&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">33</span><br><span style=\"color:#993333;\">22&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;  \"><span style=\"color:black;\">75</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td> \n</tr>\n \n<tr> \n<td style=\"padding:0.2cm;  border-bottom:double; font-weight:bolder; font-style:italic; text-align:left; vertical-align:middle;\">Total</td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">83</span><br><span style=\"color:#993333;\">55.3&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">67</span><br><span style=\"color:#993333;\">44.7&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">150</span><br><span style=\"color:#993333;\">100&nbsp;&#37;</span></td> \n</tr>\n \n</table>\n`````\n:::\n:::\n\n\n## Contingency tables (CT)\n\nRegardless of the content, contingency tables can be expressed with a common nomenclature.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"2\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">Truth</div></th>\n</tr>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">1</div></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">0</div></th>\n</tr>\n  <tr>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Prediction </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 1 </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: lightgreen !important;\">True Positive (TP)</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: #FC8D8D !important;\">False Positive (FP)</span> </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Prediction </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 0 </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: #FC8D8D !important;\">False Negative (FN)</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: lightgreen !important;\">True Negative (TN)</span> </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Contingency tables (CT)\n\nThere are a lot of metrics that can be calculated from a simple contingency tables:\n\n\n::: {.cell layout-align=\"center\"}\n<iframe src=\"https://en.wikipedia.org/wiki/Confusion_matrix\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n\n## Binomial GLM - ROC analysis \n\nThere are several metrics to compute in a confusion matrix (see [here](https://en.wikipedia.org/wiki/Confusion_matrix)). The most important are the **True Positive Rate** (TPR, also called *sensitivity*) representing the proportion of $\\hat y = 1$ when $y = 1$ using a specific threshold value and the **False Positive Rate** (FPR, also called *1 - specificity*) representing one minus the proportion of $\\hat y = 1$ when $y = 0$. We could use the `classify(fit, th = )` function to compute relevant metrics from a fitted model and a given threshold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(y ~ x, data = dat, family = binomial(link = \"logit\"))\nclassify(dat, y, x, 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   tp fp tn fn tpr       fpr       tnr fnr tot prevalence   c    ppv npv\n#> 1 22 10 18  0   1 0.3571429 0.6428571   0  50       0.44 0.5 0.6875   1\n```\n:::\n:::\n\n\n## Contingency tables (CT) metrics\n\nThe most important (and used) measures are:\n\n- the **Sensitivity** (aka **True Positive Rate** TPR or *recall*) is $\\frac{TP}{(TP + FN)}$\n- the **Specificity** (aka **True Negative Rate** TNR) is $\\frac{TN}{(FP + TN)}$\n- the **Accuracy** is $\\frac{(TP + TN)}{(TP + TN + FP + FN)}$\n- the **Positive Predictive Value** is $\\frac{TP}{TP + FP}$ or $\\frac{TPR \\times \\rho}{TPR \\times \\rho + (1 - TPR) \\times (1 - \\rho)}$ where $\\rho$ is the prevalence i.e. $TP + FP$\n- Area Under the Curve (AUC) is the area under the ROC curve that represent classification performance\n\n## Contingency tables (CT) metrics\n\n\n::: {.cell layout-align=\"center\"}\n<table class=\"table\" style=\"font-size: 25px; margin-left: auto; margin-right: auto;\">\n <thead>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"2\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">Truth</div></th>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n</tr>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">1</div></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">0</div></th>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n</tr>\n  <tr>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Test </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 1 </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: lightgreen !important;\">True Positive (TP)</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: #FC8D8D !important;\">False Positive (FP)</span> </td>\n   <td style=\"text-align:center;\"> $PPV = \\frac{TP}{TP + FP}$ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Test </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 0 </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: #FC8D8D !important;\">False Negative (FN)</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: lightgreen !important;\">True Negative (TN)</span> </td>\n   <td style=\"text-align:center;\"> $NPV = \\frac{TN}{TN + FN}$ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: white !important;\">$Sensitivity = \\frac{TP}{TP + FN}$</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: white !important;\">$Specificity = \\frac{TN}{TN + FP}$</span> </td>\n   <td style=\"text-align:center;\"> $N = TP + FP + FN + TN$ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: white !important;\">$\\rho = \\frac{TP + FN}{N}$</span> </td>\n   <td style=\"text-align:center;\"> <span style=\"     border-radius: 4px; padding-right: 4px; padding-left: 4px; background-color: white !important;\">$1 - \\rho = \\frac{FP + TN}{N}$</span> </td>\n   <td style=\"text-align:center;\"> $N = TP + FP + FN + TN$ </td>\n  </tr>\n</tbody>\n</table>\n:::\n\n\n## Contingency tables (CT) metrics\n\n\n::: {.cell layout-align=\"center\"}\n<table class=\"table\" style=\"font-size: 20px; margin-left: auto; margin-right: auto;\">\n <thead>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"2\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">Truth</div></th>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n</tr>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"2\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">1</div></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"1\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">0</div></th>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n</tr>\n  <tr>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n   <th style=\"text-align:center;\">  </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Test </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 1 </td>\n   <td style=\"text-align:center;\"> $Sensitivity \\times \\rho$ </td>\n   <td style=\"text-align:center;\"> $(1 - Specificity) \\times (1 - \\rho)$ </td>\n   <td style=\"text-align:center;\"> $PPV = \\frac{Sensitivity \\times \\rho}{Sensitivity \\times \\rho + (1 - Sensitivity) \\times (1 - \\rho)}$ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\"> Test </td>\n   <td style=\"text-align:center;font-weight: bold;\"> 0 </td>\n   <td style=\"text-align:center;\"> $(1 - Sensitivity) \\times \\rho$ </td>\n   <td style=\"text-align:center;\"> $Specificity \\times (1 - \\rho)$ </td>\n   <td style=\"text-align:center;\"> $NPV = \\frac{Specificity \\times (1 - \\rho)}{(1 - Sensitivity) \\times \\rho + Specificity \\times (1 - \\rho)}$ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;\"> $Sensitivity = \\frac{TP}{TP + FN}$ </td>\n   <td style=\"text-align:center;\"> $Specificity = \\frac{TN}{TN + FP}$ </td>\n   <td style=\"text-align:center;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;font-weight: bold;\">  </td>\n   <td style=\"text-align:center;\"> $\\rho$ </td>\n   <td style=\"text-align:center;\"> $1 - \\rho$ </td>\n   <td style=\"text-align:center;\"> 1 </td>\n  </tr>\n</tbody>\n</table>\n:::\n\n\n## Sensitivity and Specificity\n\nTo better understand the *sensitivity* and *specificity* we can use several formulations. *Sensitivity* and *Specificity* (and also other metrics) are essentially conditional probabilities.\n\n$$\nSensitivity = p(T^+|S^+) = \\frac{p(S^+|T^+)p(T^+)}{p(S^+)} = \\frac{\\frac{TP}{TP + FP}\\frac{TP + FP}{N}}{\\frac{TP + FN}{N}} = \\frac{PPVp(T^+)}{\\rho}\n$$\n\n$$\nSpecificity = p(T^-|S^-) = \\frac{p(S^-|T^-)p(T^-)}{p(S^-)} = \\frac{\\frac{TN}{TN + FN}\\frac{TN + FN}{N}}{\\frac{FP + TN}{N}} = \\frac{NPVp(T^-)}{1 -\\rho}\n$$\n\n## Positive Predictive Value (PPV)\n\nThe PPV is the probability of having a diseases given that my test is positive. While sensitivity and specificity are generally stable regardless the prevalence [but see @Brenner1997-yq], PPV is strongly affected by the disease prevalence.\n\nLet's write a function to calculate the PPV:\n\n\n::: {.cell layout-align=\"center\"}\n```r\nppv <- function(tp = NULL,\n                fp = NULL,\n                sensitivity = NULL,\n                specificity = NULL,\n                prevalence = NULL){\n  if(!is.null(tp) & !is.null(fp)){\n    tp / (tp + fp)\n  } else if(!is.null(sensitivity) & !is.null(specificity) & !is.null(prevalence)){\n    (sensitivity * prevalence) / (sensitivity * prevalence + (1 - specificity) * (1 - prevalence))\n  } else{\n    stop(\"To calculate PPV tp AND fp OR sensitivity AND specificity AND prevalence need to be specified!\")\n  }\n}\n```\n:::\n\n\n## Positive Predictive Value (PPV)\n\nNow we can calculate the PPV, fixing *sensitivity* and *specificity* by changing the **prevalence**:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# let's vary the prevalence\nprevalence <- seq(0, 1, 0.01)\n\n# computing ppv for each prevalence, fixing the specificity and sensitivity\nppvs <- ppv(sensitivity = 0.9, specificity = 0.8, prevalence = prevalence)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-17-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Youden's J, disclaimer\n\nThe Youden's J is just an option among several alternatives for choosing the best threshold. For example the `cutpointr` package:\n\n\n::: {.cell layout-align=\"center\"}\n<iframe src=\"https://cran.r-project.org/web/packages/cutpointr/vignettes/cutpointr.html#:~:text=in%20both%20classes-,Metric%20functions,-The%20included%20metrics\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n\n## Back to the example...\n\nIn our example, we can try different thresholds $t$ and se what happen to our classification metrics:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# total\nnrow(dat)\n#> [1] 50\n\n# prevalence\ntable(dat$y)\n#> \n#>  0  1 \n#> 28 22\ntable(dat$y) / nrow(dat)\n#> \n#>    0    1 \n#> 0.56 0.44\n\n# difference in the test between the two groups\ntapply(dat$x, dat$y, mean)\n#>         0         1 \n#> 0.4051844 0.7738741\n```\n:::\n\n\n## Back to the example...\n\nIntuitively, as the mean difference (on the predictor) between the two groups increase the two groups are easy to discriminate:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-20-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## ROC Curve\n\nWe can start by plotting the specificity and sensitivity for a given threshold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncmat <- classify(dat_ex_90, state, test, c = 0)\ncmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>     tp  fp   tn  fn    tpr    fpr    tnr    fnr   tot prevalence c       ppv\n#> 1 4044 908 4092 956 0.8088 0.1816 0.8184 0.1912 10000        0.5 0 0.8166397\n#>         npv\n#> 1 0.8106181\n```\n:::\n:::\n\n\n## ROC Curve\n\nWe can start by plotting the specificity and sensitivity for a given threshold:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-22-1.svg){fig-align='center' width=80%}\n:::\n:::\n\n\n## ROC\n\nWhen evaluating **sensitivity** and **specificity** with multiple thresholds we obtain the ROC curve:\n\n. . .\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/roc-anim.gif){fig-align='center' width=50%}\n:::\n:::\n\n\n## ROC\n\nThe Area Under the Curve (AUC) range between 0.5 (null classification) and 1 (perfect classification):\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-24-1.svg){fig-align='center' width=1440}\n:::\n:::\n\n\n## Youden's J\n\nGiven the trade-off between sensitivity and specificity, the choice of the best threshold ($c$) is not straightforward. An option is using the Youden's J:\n\n$$\nJ = sensitivity + specificity - 1\n$$\nThus taking the maximum of $J_i$ calculated on all threshold give us the threshold that maximize the sum between sensitivity and specificity.\n\n## Youden's J\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(104)\ndat_ex <- sim_bin_class(auc = 0.8, n = 100, prevalence = 0.5)\nfit_roc <- roc(y ~ x, data = dat_ex)\nJ <- coords(fit_roc, \"best\", best.method = \"youden\")\nJ$J <- J$specificity + J$sensitivity - 1\nJs <- fit_roc$sensitivities + fit_roc$specificities - 1\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\npar(mfrow = c(1,2))\nplot(fit_roc, main = \"ROC curve\")\npoints(x = J$specificity, y = J$sensitivity, pch = 19, col = \"firebrick\", cex = 1.4)\n\nplot(fit_roc$thresholds, Js, type = \"l\", xlab = \"Thresholds\", ylab = \"Youden's J\",\n     main = \"Youden's J\")\npoints(J$threshold, max(Js), pch = 19, col = \"firebrick\", cex = 1.4)\ntext(x = 0.6, y = 0.45, labels = sprintf(\"Cutoff = %.2f\", J$threshold))\n```\n\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-26-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Back to our example..\n\nWe can plot the ROC curve for our our example. Clearly the performance are above-chance.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nth <- c(-Inf, seq(-2, 2, 0.01), Inf)\ncmat <- classify(dat_ex, y, x, th)\nplot(cmat$fpr, cmat$tpr, type = \"l\", xlab = \"1 - Specificity\", ylab = \"Sensitivity\")\n```\n\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-27-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Back to our example..\n\nWe can calculate the AUC:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npROC::auc(fit$data$y, predict(fit, type = \"response\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Area under the curve: 0.8831\n```\n:::\n:::\n\n\n## Data simulation {.extra}\n\nAll the example so far are based on simulated data. I wrote a little function (`sim_bin_class()`) that simulate a binary classifier assuming a latent probit model. You can play around to check what happens changing the parameters.\n\n\n::: {.cell layout-align=\"center\"}\n```r\nsim_bin_class <- function(auc = NULL,\n                          d = NULL,\n                          n,\n                          prevalence,\n                          x.mean = 0,\n                          x.sd = 1,\n                          var.names = c(x = \"x\", y = \"y\")){\n  if(is.null(auc) & is.null(d)){\n    stop(\"AUC or d need to be specified\")\n  }\n\n  if(is.null(d)){\n    d <- auc_to_d(auc)\n  }\n\n  n1 <- ceiling(n * prevalence)\n  n0 <- n - n1\n  y <- rep(c(0, 1), c(n0, n1))\n  x <- ifelse(y == 1, rnorm(n1, (d/2)*x.sd + x.mean, 1), rnorm(n0, (-d/2)*x.sd + x.mean, 1))\n  dat <- data.frame(y, x)\n  names(dat) <- var.names[names(dat)]\n  return(dat)\n}\n```\n:::\n\n\n## Data simulation {.extra}\n\nLet's make an example simulating a binary classifier with an AUC of 0.7:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- sim_bin_class(auc = 0.7, n = 100, prevalence = 0.5)\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   y          x\n#> 1 0  0.8100790\n#> 2 0 -0.4872855\n#> 3 0  0.2173173\n#> 4 0 -1.3149524\n#> 5 0 -0.5828904\n#> 6 0 -1.1558787\n```\n:::\n:::\n\n\n## Data simulation {.extra}\n\nLet's see some useful descriptive plots:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_class(dat, y, x)\n```\n\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-31-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Data simulation {.extra}\n\nThe `plot_class()` function is a shortcut to produce the dotplot-density combination that is useful when plotting a binary classifier:\n\n\n::: {.cell layout-align=\"center\"}\n```r\nplot_class <- function(data, y, x){\n\n  x <- deparse(substitute(x))\n  y <- deparse(substitute(y))\n\n  if(!is.numeric(data[[y]])) stop(\"The response variable need to be numeric (0-1)\")\n\n  dens <- tapply(data[[x]], data[[y]], density)\n  ndens <- names(dens)\n\n  fit <- glm(data[[y]] ~ data[[x]], family = binomial(link = \"logit\"))\n  def.par = par(no.readonly = TRUE)\n\n  xlim <- c(min(sapply(dens, function(x) min(x$x))),\n            max(sapply(dens, function(x) max(x$x))))\n\n  ylim <- c(0, max(sapply(dens, function(x) max(x$y))))\n\n  par(mfrow = c(1, 2))\n\n  plot(dens[[1]],\n       main = \"Density Plot\",\n       xlab = x,\n       col = \"firebrick\",\n       lwd = 1.5,\n       xlim = xlim,\n       ylim = ylim)\n  rug(data[[x]][data[[y]] == ndens[1]], col = \"firebrick\", lwd = 1.5)\n  rug(data[[x]][data[[y]] == ndens[2]], col = \"dodgerblue3\", lwd = 1.5)\n  lines(dens[[2]], col = \"dodgerblue3\", lwd = 1.5)\n\n  xr <- seq(min(data[[x]]), max(data[[x]]), length.out = 500)\n\n  pr <- plogis(coef(fit)[1] + coef(fit)[2]*xr)\n\n  y_jitt <- jitter(data[[y]], 0.2)\n  y_col <- ifelse(data[[y]] == ndens[1], \"firebrick\", \"dodgerblue3\")\n\n  plot(data[[x]], y_jitt,\n       col = scales::alpha(y_col, 0.4),\n       pch = 19,\n       main = \"Dotplot\",\n       xlab = x,\n       ylab = y)\n  lines(xr, pr)\n\n  par(def.par)\n}\n```\n:::\n\n\n## Data Simulation {.extra}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit_roc <- pROC::roc(y ~ x, data = dat)\nfit_roc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> roc.formula(formula = y ~ x, data = dat)\n#> \n#> Data: x in 50 controls (y 0) < 50 cases (y 1).\n#> Area under the curve: 0.742\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nfit_roc |> \n  pROC::ggroc() + \n  geom_abline(intercept = 1, color = \"darkgrey\") +\n  coord_fixed() +\n  theme_minimal(15) +\n  xlab(\"Specificity\") +\n  ylab(\"Sensitivity\")\n```\n\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-34-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## Data Simulation {.extra}\n\nOr manually using the `classify()` function that compute common classification metrics given one or more thresholds $c_i$:\n\n\n::: {.cell layout-align=\"center\"}\n```r\nclassify <- function(data, y, x, c, na.rm = FALSE){\n  xn <- deparse(substitute(x))\n  yn <- deparse(substitute(y))\n\n  if(na.rm){\n    data <- data[complete.cases(data[, c(xn, yn)]), ]\n  }\n\n  confusion <- lapply(c, function(cr){\n    # classify based on c\n    yp <- ifelse(data[[xn]] >= cr, 1, 0)\n\n    out <- data.frame(\n      tp = sum(data[[yn]] == 1 & yp == 1),\n      fp = sum(data[[yn]] == 0 & yp == 1),\n      tn = sum(data[[yn]] == 0 & yp == 0),\n      fn = sum(data[[yn]] == 1 & yp == 0)\n    )\n\n    # rates\n    out$tpr <- with(out, tp / (tp + fn))\n    out$fpr <- with(out, fp / (fp + tn))\n    out$tnr <- 1 - out$fpr\n    out$fnr <- 1 - out$tpr\n    out$tot <- nrow(data)\n    out$prevalence <- mean(data[[yn]] == 1)\n    out$c <- cr\n    out$ppv <- with(out, tp / (tp + fp))\n    out$npv <- with(out, tn / (tn + fn))\n    out\n  })\n\n  do.call(rbind, confusion)\n}\n```\n:::\n\n\n## Data Simulation {.extra}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclassify(dat, y, x, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   tp fp tn fn tpr  fpr  tnr fnr tot prevalence c       ppv    npv\n#> 1 35 17 33 15 0.7 0.34 0.66 0.3 100        0.5 0 0.6730769 0.6875\n```\n:::\n\n```{.r .cell-code}\nclassify(dat, y, x, c(-1, 0, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   tp fp tn fn  tpr  fpr  tnr  fnr tot prevalence  c       ppv       npv\n#> 1 47 36 14  3 0.94 0.72 0.28 0.06 100        0.5 -1 0.5662651 0.8235294\n#> 2 35 17 33 15 0.70 0.34 0.66 0.30 100        0.5  0 0.6730769 0.6875000\n#> 3 15  3 47 35 0.30 0.06 0.94 0.70 100        0.5  1 0.8333333 0.5731707\n```\n:::\n\n```{.r .cell-code}\n# ~ full roc curve\ncs <- c(-Inf, seq(-4, 4, 0.1), Inf)\ncar::some(classify(dat, y, x, cs))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>    tp fp tn fn  tpr  fpr  tnr  fnr tot prevalence    c       ppv       npv\n#> 12 50 50  0  0 1.00 1.00 0.00 0.00 100        0.5 -3.0 0.5000000       NaN\n#> 18 50 49  1  0 1.00 0.98 0.02 0.00 100        0.5 -2.4 0.5050505 1.0000000\n#> 25 49 45  5  1 0.98 0.90 0.10 0.02 100        0.5 -1.7 0.5212766 0.8333333\n#> 27 49 42  8  1 0.98 0.84 0.16 0.02 100        0.5 -1.5 0.5384615 0.8888889\n#> 43 31 16 34 19 0.62 0.32 0.68 0.38 100        0.5  0.1 0.6595745 0.6415094\n#> 46 26 10 40 24 0.52 0.20 0.80 0.48 100        0.5  0.4 0.7222222 0.6250000\n#> 54 12  1 49 38 0.24 0.02 0.98 0.76 100        0.5  1.2 0.9230769 0.5632184\n#> 56  8  0 50 42 0.16 0.00 1.00 0.84 100        0.5  1.4 1.0000000 0.5434783\n#> 64  3  0 50 47 0.06 0.00 1.00 0.94 100        0.5  2.2 1.0000000 0.5154639\n#> 80  0  0 50 50 0.00 0.00 1.00 1.00 100        0.5  3.8       NaN 0.5000000\n```\n:::\n:::\n\n\n## Data Simulation {.extra}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncr <- seq(-3, 3, 0.1) # vector of thresholds\ncmat <- classify(dat, y, x, cr)\n\nplot(cmat$tnr, cmat$tpr, xlim = rev(range(cmat$tpr)), type = \"l\",\n     xlab = \"Specificity\",\n     ylab = \"Sensitivity\")\n```\n\n::: {.cell-output-display}\n![](binomial-glm-roc_files/figure-revealjs/unnamed-chunk-37-1.svg){fig-align='center' width=672}\n:::\n:::\n",
    "supporting": [
      "binomial-glm-roc_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"binomial-glm-roc_files/libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"binomial-glm-roc_files/libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}